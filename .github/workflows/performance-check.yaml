name: Performance Check (reusable)

on:
  workflow_call:
    inputs:
      test_url:
        required: false
        type: string
      throttle:
        required: false
        type: string
      baseline_path:
        required: false
        type: string
    secrets:
      token:
        required: false

concurrency:
  group: perf-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  performance-check:
    name: Performance Metrics Check
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout workflow repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.action_repository || 'your-org/perf-metrics' }}
          path: perf-metrics

      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: perf-metrics/package-lock.json

      - name: Install dependencies
        working-directory: perf-metrics
        run: npm ci --no-audit --no-fund

      - name: Determine Test URL
        id: url
        working-directory: perf-metrics
        run: |
          if [[ -n "${{ inputs.test_url }}" ]]; then
            echo "test_url=${{ inputs.test_url }}" >> $GITHUB_OUTPUT
            echo "Using custom URL: ${{ inputs.test_url }}"
          else
            BRANCH="${{ github.head_ref || github.ref_name }}"
            BRANCH_CLEAN=$(echo "$BRANCH" | sed 's/\//-/g')
            PR_ORG="${{ github.event.pull_request.head.repo.owner.login || github.repository_owner }}"
            PR_REPO="${{ github.event.pull_request.head.repo.name || github.event.repository.name }}"
            URL="https://${BRANCH_CLEAN}--${PR_REPO}--${PR_ORG}.aem.live"
            echo "test_url=$URL" >> $GITHUB_OUTPUT
            echo "Using PR preview URL: $URL"
          fi

          BASE_ORG="${{ github.event.pull_request.base.repo.owner.login || github.repository_owner }}"
          BASE_REPO="${{ github.event.pull_request.base.repo.name || github.event.repository.name }}"
          STAGE_URL="https://main--${BASE_REPO}--${BASE_ORG}.aem.live"
          echo "stage_url=$STAGE_URL" >> $GITHUB_OUTPUT
          echo "Base comparison URL: $STAGE_URL"

      - name: Use caller baseline if present
        id: baseline
        run: |
          CALLER_BASE="${{ inputs.baseline_path || 'caller/.github/performance/baseline.json' }}"
          if [[ -f "$CALLER_BASE" ]]; then
            cp "$CALLER_BASE" perf-metrics/.github/performance/baseline.json
            echo "Using caller baseline at $CALLER_BASE"
          else
            echo "Using default baseline"
          fi

      - name: Read Base Branch from baseline.json
        id: base_branch
        run: |
          BRANCH=$(node -e "const fs=require('fs');const cfg=JSON.parse(fs.readFileSync('perf-metrics/.github/performance/baseline.json','utf8'));console.log(cfg.baseBranch || 'main');")
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "Using base branch: $BRANCH"

      - name: Wait for deployment
        if: github.event_name != 'workflow_dispatch'
        run: |
          echo "Waiting for AEM deployment to be ready..."
          URL="${{ steps.url.outputs.test_url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Deployment ready (HTTP $HTTP_STATUS)"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: HTTP $HTTP_STATUS - waiting 10s..."
            sleep 10
          done
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âš ï¸ Warning: Deployment may not be ready, proceeding anyway..."
          fi

      - name: Parse PR Test URLs
        id: pr_urls
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const body = (context.payload.pull_request?.body || '').split('\n');
            const start = body.findIndex(line => line.trim().toLowerCase().startsWith('pr urls:'));
            if (start === -1) {
              core.setOutput('urls', '');
              console.log('No PR URLs section found (expecting lines after "PR Urls:")');
              return;
            }
            const urls = [];
            for (let i = start + 1; i < body.length; i++) {
              const line = body[i];
              if (!line.trim()) break;
              if (!/^\s*[-*]/.test(line)) break;
              const raw = line.replace(/^\s*[-*]\s*/, '').trim();
              if (!raw) continue;
              try {
                const u = new URL(raw);
                const hasMilolibs = u.searchParams.has('milolibs');
                urls.push({
                  name: u.toString(),
                  url: u.toString(),
                  type: hasMilolibs ? 'milolibs' : 'cloud',
                  skipMilolibs: hasMilolibs, // keep PR milolibs as provided
                });
              } catch {
                console.log(`Skipping invalid URL: ${raw}`);
              }
            }
            console.log(`Found ${urls.length} PR-specific test URLs`);
            urls.forEach(u => console.log(`  - ${u.url}`));
            core.setOutput('urls', JSON.stringify(urls));

      - name: Run Performance Check (PR)
        id: perf
        continue-on-error: true
        working-directory: perf-metrics
        env:
          TEST_URL: ${{ steps.url.outputs.test_url }}
          PR_BRANCH: ${{ github.head_ref || github.ref_name }}
          PR_ORG: ${{ github.event.pull_request.head.repo.owner.login || github.repository_owner }}
          PR_REPO: ${{ github.event.pull_request.head.repo.name || github.event.repository.name }}
          RESULTS_PATH: .github/performance/results-pr.json
          VARIANT_NAME: PR
          THROTTLE_PRESET: ${{ inputs.throttle }}
          PR_TEST_URLS: ${{ steps.pr_urls.outputs.urls }}
        run: node .github/performance/measure-performance.js "$TEST_URL"

      - name: Run Performance Check (Base)
        if: github.event_name == 'pull_request'
        continue-on-error: true
        working-directory: perf-metrics
        env:
          TEST_URL: ${{ steps.url.outputs.stage_url }}
          PR_BRANCH: ${{ steps.base_branch.outputs.branch }}
          PR_ORG: ${{ github.event.pull_request.base.repo.owner.login || github.repository_owner }}
          PR_REPO: ${{ github.event.pull_request.base.repo.name || github.event.repository.name }}
          RESULTS_PATH: .github/performance/results-stage.json
          VARIANT_NAME: Stage
          THROTTLE_PRESET: ${{ inputs.throttle }}
          PR_TEST_URLS: ${{ steps.pr_urls.outputs.urls }}
        run: node .github/performance/measure-performance.js "$TEST_URL"

      - name: Upload Performance Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-results
          path: |
            perf-metrics/.github/performance/results.json
            perf-metrics/.github/performance/results-*.json
          if-no-files-found: ignore

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const prResultsPath = 'perf-metrics/.github/performance/results-pr.json';
            const stageResultsPath = 'perf-metrics/.github/performance/results-stage.json';
            const fallbackPath = 'perf-metrics/.github/performance/results.json';
            
            let comment = '## ðŸ“Š Performance Check Results\n\n';
            
            const loadResults = (p) => fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, 'utf-8')) : null;
            const prData = loadResults(prResultsPath) || loadResults(fallbackPath);
            const stageData = loadResults(stageResultsPath);
            
            if (!prData) {
              comment += 'âš ï¸ Performance results not available.\n';
            } else {
              const { results: prResults, thresholds, passed } = prData;
              
              if (passed) {
                comment += '### âœ… All metrics within budget!\n\n';
              } else {
                comment += '### âŒ Some metrics exceed budgets\n\n';
              }
              
              const hasStage = !!stageData;
              
              if (hasStage) {
                comment += '| URLs (PR / Base) | LCP ms (PR/Base/Î”) | CLS (PR/Base/Î”) | TBT ms (PR/Base/Î”) |\n';
                comment += '|------------------|--------------------|-----------------|--------------------|\n';
              } else {
                comment += '| URL | LCP ms | CLS | TBT ms |\n';
                comment += '|-----|--------|-----|--------|\n';
              }
              
              const stageResults = hasStage ? stageData.results : [];
              
              const byName = new Map();
              for (const r of prResults) {
                const key = r.name || new URL(r.url).pathname || '/';
                byName.set(key, { pr: r });
              }
              for (const r of stageResults) {
                const key = r.name || new URL(r.url).pathname || '/';
                const entry = byName.get(key) || {};
                entry.stage = r;
                byName.set(key, entry);
              }
              
              const formatDelta = (prVal, stVal, fmt) => {
                if (prVal == null && stVal == null) return 'N/A';
                const prStr = prVal == null ? 'N/A' : fmt(prVal);
                const stStr = stVal == null ? 'N/A' : fmt(stVal);
                if (prVal == null || stVal == null) return `${prStr} / ${stStr} / N/A`;
                const delta = prVal - stVal;
                const sign = delta > 0 ? '+' : '';
                return `${prStr} / ${stStr} / ${sign}${fmt(delta)}`;
              };
              const overBudget = (val, key) => val != null && thresholds?.[key]?.budget != null && val > thresholds[key].budget;
              const mark = (val, key, cell) => overBudget(val, key) ? `âŒ ${cell}` : cell;
              
              for (const [pageName, { pr: result, stage: base }] of byName) {
                const fmtMs = (v) => `${Math.round(v)}ms`;
                const fmtCls = (v) => v.toFixed(3);
                
                const lcpCell = hasStage
                  ? `${formatDelta(result?.lcp, base?.lcp, fmtMs)}`
                  : `${result?.lcp ? Math.round(result.lcp) : 'N/A'}ms`;
                const clsCell = hasStage
                  ? `${formatDelta(result?.cls, base?.cls, fmtCls)}`
                  : `${result?.cls ?? 'N/A'}`;
                const tbtCell = hasStage
                  ? `${formatDelta(result?.tbt, base?.tbt, fmtMs)}`
                  : `${result?.tbt ? Math.round(result.tbt) : 'N/A'}ms`;
                
                const lcpOut = mark(result?.lcp, 'lcp', lcpCell);
                const clsOut = mark(result?.cls, 'cls', clsCell);
                const tbtOut = mark(result?.tbt, 'tbt', tbtCell);
                
                const urlVal = result?.url || base?.url || pageName;
                const baseUrlVal = base?.url || '';
                const urlCell = hasStage
                  ? `PR: ${urlVal}<br>Base: ${baseUrlVal || 'N/A'}`
                  : urlVal;
                
                if (hasStage) {
                  comment += `| ${urlCell} | ${lcpOut} | ${clsOut} | ${tbtOut} |\n`;
                } else {
                  comment += `| ${urlCell} | ${lcpOut} | ${clsOut} | ${tbtOut} |\n`;
                }
              }
              
              comment += '\n<details>\n<summary>ðŸ“¦ Heaviest resources (top 5 per page)</summary>\n\n';
              const variants = [
                { label: 'PR', data: prResults },
              ];
              if (hasStage) {
                variants.push({ label: 'Base', data: stageResults });
              }
              
              for (const variant of variants) {
                comment += `**${variant.label}**\n`;
                for (const result of variant.data) {
                  const pageUrl = result.url || '/';
                  comment += `- ${pageUrl}\n`;
                  if (result.topResources && result.topResources.length) {
                    for (const res of result.topResources) {
                      const sizeKb = res.size ? (res.size / 1024).toFixed(1) : '0.0';
                      comment += `  - ${sizeKb}KB â€” ${res.name}\n`;
                    }
                  } else {
                    comment += '  - No resource data collected\n';
                  }
                }
                comment += '\n';
              }
              comment += '</details>\n';
              
              comment += '\n<details>\n<summary>ðŸ“‹ Budget Thresholds</summary>\n\n';
              comment += '| Metric | Budget | Description |\n';
              comment += '|--------|--------|-------------|\n';
              comment += `| LCP | ${thresholds.lcp.budget}ms | ${thresholds.lcp.description} |\n`;
              comment += `| CLS | ${thresholds.cls.budget} | ${thresholds.cls.description} |\n`;
              comment += `| TBT | ${thresholds.tbt.budget}ms | ${thresholds.tbt.description} |\n`;
              comment += `| JS Size | ${(thresholds.jsSize.budget / 1024).toFixed(0)}KB | ${thresholds.jsSize.description} |\n`;
              comment += '\n</details>\n';
            }
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('ðŸ“Š Performance Check Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment,
              });
            }
